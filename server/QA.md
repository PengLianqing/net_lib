// ::usleep(10*1000);
// std::cout<<times++<<","<<actEvNum<<std::endl;

// if( ++times%1000000==0 ){
    std::cout<<times++<<" " <<actEvNum<<std::endl;
// }
感觉问题应该出在timefd上。

添加超时，epoll lt

# pqs限流算法

封装了一个类，通过pass函数来实现pqs限流。
通过自旋锁、原子变量实现令牌桶。
根据时间向令牌桶中补充令牌，原子变量实现的自旋锁保证线程间的互斥访问。


# 协程

单线程协程与多线程协程：
单线程协程，一个协程等待队列，在执行yield时，可以直接在协程中切换到协程队列中的其他协程；

网络库下的协程，是多线程的协程、可以根据每个线程的负载情况动态的将协程分配到线程；
执行协程切换需要一个调度主协程，即协程切换会切换到调度主协程，主协程里实现了epoll、定时器上事件的处理和就绪队列协程的运行、资源回收等操作。

# 特点

协程的切换API通过Linux的ucontext实现。
其他的协程实现方式有汇编、switch语法、setjmp()和longjmp()函数跳转等。

IO复用通过epoll水平触发+非阻塞IO实现。epoll的用户数据中保存了对应协程的上下文信息，实现类似回调函数的操作，通过遍历epoll返回数组，可以直接将对应的协程信息添加到就绪队列。使用非阻塞IO可以充分利用线程的其余时间来处理其他任务。

协程对象的内存管理通过对象池实现，对象池通过原子变量实现的自旋锁保证线程间的互斥访问。
对象池将相等大小的内存块通过链表连接，实现内存的分配和释放。

读写锁：使用原子变量保存读取的任务数，使用状态机描述读写锁的状态变化，等待线程队列存放等待锁的协程，使用自旋锁保护读写锁中的数据。
用原子变量实现了读写锁，如果协程尝试获取锁失败会切换协程，将自己的上下文添加到读写锁的waitingCo_等待队列，当其他线程释放锁后，会从读写锁的等待队列唤醒等待锁的协程。

锁：
对象池通过自旋锁保证不同线程间的互斥访问；
读写锁可以用于在多线程的协程中实现线程安全的数据结构与数据访问。

# 框架结构

全局单例调度器对象Sheduler，包含一个**协程管理对象的数组**和一个**事件分配器**：
    通过双重锁定的单例模式，实现多线程下的初始化。
    协程管理对象的数组实际上就是对每个线程的封装，每个元素对应一个线程，这个线程实现了对该线程上协程的管理；
    事件分配器中指定了两种协程分配模式，决定将新协程或唤醒的协程放到哪一个线程去执行。

协程管理对象本质是一个线程，其中封装了epoll、小根堆实现的定时器、协程队列、协程集合和主协程。
    epoll用于唤醒连接事件、读写事件、定时器事件，epoll的用户数据中储存了协程的上下文信息，epoll返回后依次执行epoll事件对应的协程。
    定时器使用timefd实现唤醒，使用小根堆来维护待唤醒的定时事件。
    主协程是是每个新建线程执行的第一个协程，也是用户创建的协程进行协程切换后运行的程序。它负责处理epoll返回，查找超时的定时事件，并循环执行就绪队列中待执行的协程。

与协程相关的数据结构有各种协程队列（就绪、定时事件、epoll事件、运行事件等的队列）和set集合（用于判断协程是否已经运行完毕回收）.

# 运行过程

程序一开始，初始化调度器对象，创建线程，初始化每个线程中的epoll、定时器和用于协程任务调度的主协程。
主协程创建后就依次循环执行：epoll事件、超时事件对应的协程的唤醒，和新加入的协程的执行，以及对执行完的协程资源的回收。
当主协程调用epoll_wait检测到新的客户端连接或读写事件时，将对应事件的协程添加到执行队列；
当发现定时器中有超时事件需要执行时，将超时事件对应的协程添加到执行队列；
当发现用户调用过创建协程操作时，将创建的协程添加到执行队列依次执行。

用户创建协程，首先为协程从对象池中分配资源，将协程添加到新任务队列，然后通过timerfd唤醒epoll，进而可以在下一次主协程运行时运行新的协程；
服务器初始化时，建立一个用于监听、建立连接的协程。监听socket设置为非阻塞，如果尝试accept连接没有客户端，会将监听socket添加到epoll，然后切换回主协程，等待epoll连接事件发生时会被主协程从新唤醒继续执行。
要与某个客户端发生读写事件时，首先对非阻塞的socket文件尝试读写，如果能成功读写则协程继续运行；如果当前不可读写，则将当前socket的读写事件添加到epoll，然后切换回主协程，等待epoll读写事件发生时会被主协程从新唤醒继续执行。
要实现延时时，将协程信息添加到定时器的小顶堆，修改timefd，然后切换回主协程，等待超时事件发生时会被主协程从新唤醒继续执行。


# 线程安全的数据结构
队列、栈、哈希表、链表

哈希：为每个哈希桶设置互斥锁保护，提高并发。
队列：使用智能指针+模版+互斥锁、条件变量实现，push、pop获取锁之前完成内存的分配，减小了锁的粒度，对于较大的对象提高了性能。
     通过傀儡节点实现了，head tail始终指向不同的节点，防止了访问的竞争。
栈：使用智能指针+互斥锁+std::stack实现
链表：为每个节点分配互斥锁和智能指针（数据（sharedptr）和next（uniqueptr）），对链表的访问只需要锁定某些节点而不是全部。

###############################################################################################################

根据计算机核心数开启对应数量的线程，每一个线程对应一个Processor实例，协程Coroutine实例运行在Processor的主循环中，Procesor使用epoll和定时器timer进行任务调度。

Scheduler是一个全局单例，在某个线程中调用co_go()运行一个新协程后，实际会调用该实例的方法，选择协程最少的（或其他策略）Processor接管新的协程。

单例模式，
全局单例：调度器对象Sheduler，包含线程数组和事件分配器，负责创建、回收线程和分配协程。
调度器对象根据计算机核心数创建对应数量的协程管理对象，每个协程管理对象负责管理一个线程。
每一个协程管理对象包括一个epoll对象、一个定时器对象和一个协程的对象池。
协程管理对象通过epoll和定时器进行协程调度，
当socket出现读写事件或定时器到期会触发线程切换。

epoll负责监听socket和定时器timerfd，
epoll的用户数据中直接存放上下文信息，epoll返回后就可以根据上下文信息来唤醒对应的协程。（类似epoll反应堆模型的回调机制）

定时器对象，

主协程，执行获取epoll事件、定时器超时的事件对应的协程和新的协程；清除执行完的协程。
（epollwait，小顶堆超时，goCo这些协程都依次执行）
timerfd添加到epoll的原因是，需要通过epoll唤醒某些定时任务，如果长时间无连接或读写事件，线程可能阻塞在epollwait中无法执行一些延时的协程。

协程：


单例模式；
调度器对象Sheduler是全局单例，包含一个**协程管理对象的数组**和一个**事件分配器**：
    协程管理对象的数组实际上就是对每个线程的封装，每个元素对应一个线程，这个线程实现了对该线程上协程的管理；
    事件分配器中指定了两种协程分配模式，决定将新协程或唤醒的协程放到哪一个线程去执行。
协程管理对象本质是一个线程，其中封装了epoll、小根堆实现的定时器和协程的唤醒。

程序一开始，初始化调度器对象，创建线程，初始化每个线程中的epoll、定时器和用于协程任务调度的主协程。
主协程创建后就依次循环执行：epoll事件、超时事件对应的协程的唤醒，和新加入的协程的执行，以及对执行完的协程资源的回收。
当主协程调用epoll_wait检测到新的客户端连接或读写事件时，将对应事件的协程添加到执行队列；
当发现定时器中有超时事件需要执行时，将超时事件对应的协程添加到执行队列；
当发现用户调用过创建协程操作时，将创建的协程添加到执行队列依次执行。

队列和set集合，
对象池通过自旋锁，
创建协程，首先为协程从对象池中分配资源，将协程添加到新任务队列，然后通过timerfd唤醒epoll，进而可以在下一次主协程运行时运行新的协程；
服务器初始化时，建立一个用于监听、建立连接的协程，同样使用非阻塞socket，如果尝试accept连接没有客户端，会将监听socket添加到epoll，然后切换回主协程。
当与某个客户端发生读写事件时，首先对非阻塞的socket文件尝试读写，如果能成功读写则协程继续运行；如果当前不可读写，则将当前socket的读写事件添加到epoll，然后切换回主协程。
用户想实现延时时，将协程信息添加到定时器的小顶堆，修改timefd，然后切换回主协程。

读写锁：
使用原子变量保存读取的任务数，使用状态机描述读写锁的状态变化，等待线程队列存放等待锁的协程，使用自旋锁保护读写锁中的数据。
用原子变量实现了读写锁，如果协程尝试获取锁失败会切换协程，将自己的上下文添加到读写锁的waitingCo_等待队列，当其他线程释放锁后，会从读写锁的等待队列唤醒等待锁的协程。


内存池：
用于分配协程对象，原子变量实现的自旋锁实现线程对内存池的互斥访问；
（优化）
内存池通过链表将空闲内存串起来。

#####

协程的切换API通过Linux的ucontext实现，其他的协程实现方式有汇编、switch语法、setjmp()和longjmp()函数跳转。

IO复用通过，epoll水平触发 + 非阻塞实现。特点：结合协程的切换可以实现...

协程对象的内存管理通过对象池实现，对象池通过原子变量实现的自旋锁保证线程间的互斥访问。
对象池将相等大小的内存块通过链表连接，实现内存的分配和释放。

读写锁：使用原子变量保存读取的任务数，使用状态机描述读写锁的状态变化，等待线程队列存放等待锁的协程，使用自旋锁保护读写锁中的数据。
用原子变量实现了读写锁，如果协程尝试获取锁失败会切换协程，将自己的上下文添加到读写锁的waitingCo_等待队列，当其他线程释放锁后，会从读写锁的等待队列唤醒等待锁的协程。

框架：
全局单例调度器对象Sheduler，包含一个**协程管理对象的数组**和一个**事件分配器**：
    协程管理对象的数组实际上就是对每个线程的封装，每个元素对应一个线程，这个线程实现了对该线程上协程的管理；
    事件分配器中指定了两种协程分配模式，决定将新协程或唤醒的协程放到哪一个线程去执行。

协程管理对象本质是一个线程，其中封装了epoll、小根堆实现的定时器、任务列表和主协程。
    epoll用于唤醒连接事件、读写事件、定时器事件，epoll的用户数据中储存了协程的上下文信息，epoll返回后依次执行epoll事件对应的协程。
    定时器使用timefd实现唤醒，使用小根堆来维护待唤醒的定时事件。
    主协程是是每个新建线程执行的第一个协程，也是用户创建的协程进行协程切换后运行的程序。它负责处理epoll返回，查找超时的定时事件，并循环执行就绪队列中待执行的协程。

与协程相关的数据结构有各种协程队列（就绪、定时事件、epoll事件、运行事件等的队列）和set集合（用于保存所有的协程，方便查找和删除）.

运行过程：
程序一开始，初始化调度器对象，创建线程，初始化每个线程中的epoll、定时器和用于协程任务调度的主协程。
主协程创建后就依次循环执行：epoll事件、超时事件对应的协程的唤醒，和新加入的协程的执行，以及对执行完的协程资源的回收。
当主协程调用epoll_wait检测到新的客户端连接或读写事件时，将对应事件的协程添加到执行队列；
当发现定时器中有超时事件需要执行时，将超时事件对应的协程添加到执行队列；
当发现用户调用过创建协程操作时，将创建的协程添加到执行队列依次执行。

用户创建协程，首先为协程从对象池中分配资源，将协程添加到新任务队列，然后通过timerfd唤醒epoll，进而可以在下一次主协程运行时运行新的协程；
服务器初始化时，建立一个用于监听、建立连接的协程。监听socket设置为非阻塞，如果尝试accept连接没有客户端，会将监听socket添加到epoll，然后切换回主协程，等待epoll连接事件发生时会被主协程从新唤醒继续执行。
要与某个客户端发生读写事件时，首先对非阻塞的socket文件尝试读写，如果能成功读写则协程继续运行；如果当前不可读写，则将当前socket的读写事件添加到epoll，然后切换回主协程，等待epoll读写事件发生时会被主协程从新唤醒继续执行。
要实现延时时，将协程信息添加到定时器的小顶堆，修改timefd，然后切换回主协程，等待超时事件发生时会被主协程从新唤醒继续执行。